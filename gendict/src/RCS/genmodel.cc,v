head	1.27;
access;
symbols;
locks; strict;
comment	@// @;


1.27
date	98.07.13.16.06.42;	author markc;	state Exp;
branches;
next	1.26;

1.26
date	97.08.18.03.05.27;	author markc;	state Exp;
branches;
next	1.25;

1.25
date	97.05.03.16.16.59;	author markc;	state Exp;
branches;
next	1.24;

1.24
date	97.03.05.17.41.20;	author markc;	state Exp;
branches;
next	1.23;

1.23
date	97.03.02.04.45.46;	author markc;	state Exp;
branches;
next	1.22;

1.22
date	97.02.16.06.57.12;	author markc;	state Exp;
branches;
next	1.21;

1.21
date	96.02.20.03.44.23;	author markc;	state Exp;
branches;
next	1.20;

1.20
date	96.02.17.18.46.13;	author markc;	state Exp;
branches;
next	1.19;

1.19
date	96.02.17.16.42.31;	author markc;	state Exp;
branches;
next	1.18;

1.18
date	96.02.14.15.07.31;	author markc;	state Exp;
branches;
next	1.17;

1.17
date	96.02.07.04.02.19;	author markc;	state Exp;
branches;
next	1.16;

1.16
date	96.01.20.18.18.47;	author markc;	state Exp;
branches;
next	1.15;

1.15
date	96.01.20.17.23.28;	author markc;	state Exp;
branches;
next	1.14;

1.14
date	96.01.13.09.45.52;	author markc;	state Exp;
branches;
next	1.13;

1.13
date	96.01.13.09.41.29;	author markc;	state Exp;
branches;
next	1.12;

1.12
date	95.11.12.23.04.28;	author chapman;	state Exp;
branches;
next	1.11;

1.11
date	95.11.08.19.40.58;	author chapman;	state Exp;
branches;
next	1.10;

1.10
date	95.11.08.19.25.10;	author chapman;	state Exp;
branches;
next	1.9;

1.9
date	95.10.12.16.04.46;	author markc;	state Exp;
branches;
next	1.8;

1.8
date	95.09.25.03.10.22;	author markc;	state Exp;
branches;
next	1.7;

1.7
date	95.08.24.20.13.47;	author markc;	state Exp;
branches;
next	1.6;

1.6
date	95.08.24.18.32.59;	author markc;	state Exp;
branches;
next	1.5;

1.5
date	95.08.24.02.02.27;	author markc;	state Exp;
branches;
next	1.4;

1.4
date	95.08.24.01.02.51;	author markc;	state Exp;
branches;
next	1.3;

1.3
date	95.08.23.19.12.37;	author markc;	state Exp;
branches;
next	1.2;

1.2
date	95.08.14.01.01.54;	author markc;	state Exp;
branches;
next	1.1;

1.1
date	95.07.30.17.06.55;	author markc;	state Exp;
branches;
next	;


desc
@Initial Check-in
@


1.27
log
@Major changes
-m,-d,-o,-u,-q,-i,-b,-g
@
text
@/*
 * Generate Model Program 
 * Copyright (c) Mark T. Chapman 1995
 *
 * $Id: genmodel.cc,v 1.26 1997/08/18 03:05:27 markc Exp markc $
 *
 * $Log: genmodel.cc,v $
 * Revision 1.26  1997/08/18 03:05:27  markc
 * Changed yy* to zz* to avoid multiple symbols for LEX parsers
 *
 * Revision 1.25  1997/05/03 16:16:59  markc
 * Added statis doc to usage()
 *
 * Revision 1.24  1997/03/05 17:41:20  markc
 * Added static char rcsid []  = "@@(#)$Id: genmodel.cc,v 1.26 1997/08/18 03:05:27 markc Exp markc $";
 *
 * Revision 1.23  1997/03/02 04:45:46  markc
 * Big changes: [-s] added, printStats, SENTMDL_CAP*, capWord fixed, usage()
 *
 * Revision 1.22  1997/02/16 06:57:12  markc
 * BST replaced with RBT
 *
 * Revision 1.21  1996/02/20 03:44:23  markc
 * *** empty log message ***
 *
// Revision 1.20  1996/02/17  18:46:13  markc
// use freq for dictrecords
//
// Revision 1.19  1996/02/17  16:42:31  markc
// added grambase.def generation automatically
//
// Revision 1.18  1996/02/14  15:07:31  markc
// use shift and cap
// ignore quotation marks
// output mstrmodel instead of model
//
// Revision 1.17  1996/02/07  04:02:19  markc
// removed #include "rbt.h" -- duplicate -- only needed once ;)
//
// Revision 1.16  1996/01/20  18:18:47  markc
// replaced BST with RBT for dictionary
//
// Revision 1.15  1996/01/20  17:23:28  markc
// use rbt version of raofalt instead of bst
//
// Revision 1.14  1996/01/13  09:45:52  markc
// removed cout << Model
//
// Revision 1.13  1996/01/13  09:41:29  markc
// use new sentnode enabled sentmdl
//
// Revision 1.12  1995/11/12  23:04:28  chapman
// Converted to use the .alt files and everything
// it actually works now.
//
// Revision 1.11  1995/11/08  19:40:58  chapman
// Removed #include "dictent.h"
//
// Revision 1.10  1995/11/08  19:25:10  chapman
// Compiled with new "records" instead of "mstr*"
//
// Revision 1.9  1995/10/12  16:04:46  markc
// Fixed the repeat-last-type-when-end-of-sentence bug./
//
// Revision 1.8  1995/09/25  03:10:22  markc
// Check It In -- thank you.
//
// Revision 1.7  1995/08/24  20:13:47  markc
// update
//
// it now works well with babble 1.1
//
// Revision 1.6  1995/08/24  18:32:59  markc
// Use sentenceModel class instead of just an array of strings for Model
//
// Revision 1.5  1995/08/24  02:02:27  markc
// Revised Model, added MARK_'s,
// Next I need to optimize the sentence model format.
//
// Revision 1.4  1995/08/24  01:02:51  markc
// Everything seems to work now -- needs clean-up though
//
// Revision 1.3  1995/08/23  19:12:37  markc
// Correctly creates distdict.dat -- does not yet deal with disttype.dat
//
// Revision 1.2  1995/08/14  01:01:54  markc
// In progress -- just back it up because it is kinda stable -- but wrong!
//
// Revision 1.1  1995/07/30  17:06:55  markc
// Initial revision
//
 *
 */

static char rcsid []  = "@@(#)$Id: genmodel.cc,v 1.26 1997/08/18 03:05:27 markc Exp markc $";

#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <stdlib.h>
#include <String.h>
#include "../../mtc++/include/MTC++.h"
#include "../../mtc++/include/mstring.h"
#include "../../mtc++/include/errormsg.h"
#include "../../mtc++/include/rbt.h"
#include "../../mtc++/include/list.h"
#include "../../mtc++/include/raof.h"
#include "../../mtc++/include/raofalt.h"
#include "../../mtc++/include/raof2rbt.h"
#include "../include/lexword.h"
#include "../include/dictrec.h"
#include "../include/typerec.h"
#include "../include/typearec.h"
#include "../include/dictarec.h"
#include "../include/sentnode.h"
#include "../include/sentmdl.h"
#include "../include/dconst.h"

int zzlex();
extern char *zztext;
extern FILE *zzin;

long badWordCounter=0;
long modelCounter=0;
long wordCounter=0;

void usage();
void printStats();

long loadTypeAltRecords(MTCRBT <MTCtypeAltRecord> &, const MTCstring &);
void clearTypeAltRecFreq(MTCtypeAltRecord *);

void createDistDict(MTCdictRecord *);
void dumpDictionary(MTCdictRecord *, long);
void dumpModelSet(MTCsentenceModel *, long);
void dumpTypeAltRecSet(MTCtypeAltRecord *);
void dumpBadWords(MTCstring *str);
const MTCstring removeNewLines(const MTCstring & aString);

ofstream *badWordFile=NULL;
ofstream *grammarFile=NULL;
MTCwriteRAOF <MTCdictRecord> *dictionaryWriteRAOF=NULL;
MTCwriteRAOF <MTCtypeAltRecord>  *typeWriteRAOF=NULL;
MTCwriteRAOF <MTCsentenceModel>  *modelWriteRAOF=NULL;
MTCRBT <MTCtypeAltRecord> typeAltRecSet;
MTCRBTFreq <MTCsentenceModel> modelSet;
MTCRBTFreq <MTCdictRecord> dictionary;	// new dictionary 
MTCRBT <MTCstring> badWords;

int main(int argc, char *argv[])
{
	BOOL smallMode=FALSE;
	MTCstring inputDictPrefix("mstr");
	MTCstring outputDictPrefix("dist");
	MTCstring outputModelPrefix("dist");
	MTCstring grammarName;
	MTCstring inputFileName;
	long jumpCount=0;
	MTCstring badWordFileName;
	int updateFreq=1000;
	char ch;

	while ((ch = getopt(argc, argv, "hsd:i:j:b:g:o:u:qm:")) != EOF)
	{
		switch(ch) 
		{
		case 'd':
			inputDictPrefix=optarg;
			break;
		case 'i':
			inputFileName=optarg;
			break;
		case 'j':
			jumpCount=atoi(optarg);	
			break;
		case 'u':
			updateFreq=atoi(optarg);	
			break;
		case 'q':
			updateFreq=0;
			break;
		case 'b':
			badWordFileName=optarg;
			break;
		case 's':
			smallMode=TRUE;
			break;
		case 'o':
			outputDictPrefix=optarg;
			outputModelPrefix=optarg;
			break;
		case 'g':
			grammarName=optarg;
			break;
		case 'm':
			outputModelPrefix=optarg;
			break;
		case 'h':
		default:
			usage();	
			exit(-1);
		}
	}

	argc -= optind;
	argv += optind;

	cerr << "Sentence Model Analysis Started..." << endl;

	cerr << "\tprogram options:" <<endl;
	
	if (smallMode==TRUE)
	{
		cerr << "\t\tsmall memory mode [-s] selected" << endl;
	}
	else
	{
		cerr << "\t\tload tables into RAM -- If I run out of memory, try [-s]" << endl;
	}

	cerr << "\t\tinput dictionary prefix: " << inputDictPrefix << endl;

	if (inputFileName.length())
	{
		cerr << "\t\tinput file name: " << inputFileName << endl;

		if ((zzin=fopen(inputFileName.c_str(),"r"))==NULL)
		{
			perror(inputFileName.c_str());
			errorMsg(EMT_ABORT, "I could not open the input file","main()");
			exit(-1);
		}
	}
	else
	{
		cerr << "\t\tread from stdin" << endl;
	}

	if (jumpCount)
	{
		cerr << "\t\t(-j NOT YET IMPLEMENTED) skip the first " << jumpCount << " lines" << endl;
	}

	if (badWordFileName.length())
	{
		cerr << "\t\tsend bad word list to: " << badWordFileName << endl;
		if ((badWordFile = new ofstream(badWordFileName.c_str()))==NULL)
		{
			perror(badWordFileName.c_str());
			errorMsg(EMT_ABORT, "I could not create the bad word file", "main()");
			exit(-1);
		}
	}

	if (grammarName.length())
	{
		cerr << "\t\tdump a (probably useless) grammar to: " << grammarName << endl; 

		if ((grammarFile = new ofstream(grammarName.c_str()))==NULL)
		{
			perror(grammarName.c_str());
			errorMsg(EMT_ABORT, "I could not create the grammar output file", "main()");
			exit(-1);
		}
	}

	if (outputDictPrefix.length())
	{
		cerr << "\t\toutput dictionary prefix: " << outputDictPrefix << endl;
		dictionaryWriteRAOF= new MTCwriteRAOF <MTCdictRecord> (outputDictPrefix + "dict");

		if (dictionaryWriteRAOF==NULL)
		{
			perror(outputDictPrefix.c_str());
			errorMsg(EMT_ABORT,"I could not create the output dictionary twlist record table","main()"); 
			exit (-1);
		}

		typeWriteRAOF= new MTCwriteRAOF <MTCtypeAltRecord> (outputDictPrefix + "type");
		if (typeWriteRAOF==NULL)
		{
			perror(outputDictPrefix.c_str());
			errorMsg(EMT_ABORT,"I could not create the output dictionary type table","main()"); 
			exit (-1);
		}
	}

	if (outputModelPrefix.length())
	{
		cerr << "\t\toutput model prefix: " << outputModelPrefix << endl;
		modelWriteRAOF= new MTCwriteRAOF <MTCsentenceModel> (outputModelPrefix + "model");

		if (modelWriteRAOF==NULL)
		{
			perror(outputModelPrefix.c_str());
			errorMsg(EMT_ABORT,"I could not create the model table","main()"); 
			exit (-1);
		}
	}

	BOOL good;
	MTCreadRAOF <MTCdictRecord> dictRecordReadRAOF (inputDictPrefix + "dict");
	MTCRBT <MTCdictRecord> dictRecordReadRBT;
	MTCdictRecord currentDictRec;
	MTCtypeAltRecord tempTypeAltRecord;
	MTCtypeAltRecord *foundTypeAltRec;
	long badTypeIndex;
	MTCstring zztextString;
	MTCsentenceModel model;
	MTCdictRecord find;
	const MTCdictRecord *found;
	int retval;
	char buffer[20];
	MTCstring bufferString;
	long i;
	BOOL capWord=FALSE;
 
	// load type alternate records

	cerr << "Step 1: Load type information from input dictionary..." << endl;

	badTypeIndex=loadTypeAltRecords(typeAltRecSet, inputDictPrefix);

	cerr << "\t" << typeAltRecSet.getCount() << " types in dictionary" << endl;

	cerr << "Step 2: Load input dictionary..." << endl;

	if (smallMode==FALSE)
	{
		MTCraofToRBT <MTCdictRecord> loader;

		if (loader.doIt(dictRecordReadRAOF, dictRecordReadRBT)==FALSE)
		{
			errorMsg(EMT_ABORT, "I could not load the dictionary table into Memory", "main()"); 
			return -1;
		}
	}

	cerr << "\t" << dictRecordReadRAOF.getCount() << " words in dictionary" << endl;

	// process words from stdin

	cerr << "Step 3: Scanning sentences from stdin..." << endl;

	good=TRUE;

	for(;;)
	{
		retval=zzlex();		// read the next token from stdin

		if (zztext[0]=='\0')	// is it eof?
		{
			break;
		}

		zztextString=zztext;
		zztextString.toLower();	// everything lower case for now...

		currentDictRec.setValue(zztextString);

		switch (retval)
		{
			case END_OF_WORD:	
				// uppercase?

				wordCounter++;

				if ((zztext[0]>='A')&&(zztext[0]<='Z'))
				{
					MTCstring tstr(zztext);

					tstr.toUpper();

					if (tstr==zztext)
					{
						capWord=TRUE;
					}
					else
					{
						model.appendPunctuation(SENTMDL_CAP_NEXT_LETTER);
					}
				}

				// is it already in dictionary?

				if ((found=dictionary.find(currentDictRec))!=NULL)
				{
					// increment frequency

					MTCdictRecord d(*found);
					dictionary.add(d, FALSE);

					// append type index to model and exit

					if (capWord==TRUE)
					{
						model.appendPunctuation(SENTMDL_CAPSLOCK_ON);
					}

					model.appendTypeIndex(found->getTypeIndex());
					if (capWord==TRUE)
					{
						model.appendPunctuation(SENTMDL_CAPSLOCK_OFF);
						capWord=FALSE;
					}

					break;
				}

				// otherwise look it up in master RAOF

				if (smallMode==TRUE)
				{
					found=dictRecordReadRAOF.find(currentDictRec);
				}
				else
				{
					found=dictRecordReadRBT.find(currentDictRec);
				}

				if (found!=NULL)
				{
					currentDictRec=*found;
				}
				else
				{
					// bad word processing 
					
					badWordCounter++;

					if (badWordFile!=NULL)
					{
						MTCstring bad(currentDictRec.getValue());
						badWords.add(bad);
						currentDictRec.setTypeIndex(badTypeIndex);
						good=FALSE;
					}

					// do not add bad words to dist dict

					break;
				}

				// look up the the type frequency

				tempTypeAltRecord.setIndex(currentDictRec.getTypeIndex());

				foundTypeAltRec=typeAltRecSet.find(tempTypeAltRecord);

				if (foundTypeAltRec==NULL)
				{
					cerr << "ERROR: Type Not Found" << tempTypeAltRecord << " -- The type table does not match the dictionary." << endl;
					break;
				}

				// set the bitstring in the dictrec
	
				currentDictRec.setBitString(foundTypeAltRec->getFreq());

				// increment the type freq
			
				foundTypeAltRec->setFreq(foundTypeAltRec->getFreq()+1);

				// add the currentDictRec

				dictionary.add(currentDictRec);

				// add the type index to the model

				if (capWord==TRUE)
				{
					model.appendPunctuation(SENTMDL_CAPSLOCK_ON);
				}

				model.appendTypeIndex(currentDictRec.getTypeIndex());

				// if all caps, go back to lowercase

				if (capWord==TRUE)
				{
					model.appendPunctuation(SENTMDL_CAPSLOCK_OFF);
					capWord=FALSE;
				}

				break;

			case END_OF_SENTENCE:	
				if (good==TRUE)
				{
					// add the punctuation to model

					model.appendPunctuation(removeNewLines(currentDictRec.getValue()));
					// add the model to the modelSet

					modelSet.add(model);
				}

				modelCounter++;

				if ((updateFreq)&&(modelCounter%updateFreq)==0)
				{
					printStats();
				}
			
				model.clear();
				good=TRUE;
				break;

			case PUNCTUATION:
				model.appendPunctuation(removeNewLines(currentDictRec.getValue()));
				break;
		}
	}

	// close the dictionary

	printStats();

	cerr << endl; 

	if (smallMode==FALSE)
	{
		cerr << "\tremoving mstrdict.dat from memory..." << endl;
		dictRecordReadRBT.clear();
	}
	

	// warn about bad words

	cerr << "Step 4: Process bad word list" << endl;

	if (badWordCounter==0)
	{
		cerr << "\tAll words in sample texts were defined! " << endl;
	}
	else
	{
		if (badWordFile!=NULL)
		{
			cerr << "\tWarning: " << badWordCounter << " instances of undefined words." << endl;
			cerr << "\t         " << badWords.getCount() << " unique undefined words." << endl; 
			cerr << "\t          Please see " << badWordFileName << endl;
			badWords.forEach(dumpBadWords);
		}
	}

	// dump the model set

	cerr << "Step 5: Store the sentence models..." << endl;

	cerr << "\tStoring " << modelSet.getCount() << " Models..." << endl;

	if (grammarFile!=NULL)
	{
		cerr << "\tStoring " << modelSet.getCount() << " Models..." << endl;

		*grammarFile << "// rules generated by genmodel" << endl;
		*grammarFile << "// these should match mstrmodel.dat" << endl;
		*grammarFile << "// this grammar will use a LOT of memory if used with nicetext" << endl;
		*grammarFile << "// the real purpose is to assist in manual grammar generation" << endl;
		*grammarFile << endl;
		*grammarFile << "SENTENCE:" << endl;
		modelSet.forEachFreq(dumpModelSet);

		*grammarFile << "\t;" << endl;
		*grammarFile << endl;
	}
	else
	{
		if (modelWriteRAOF!=NULL)
		{
			modelSet.forEachFreq(dumpModelSet);
		}
	}

	modelSet.clear();

	// make this dump dictionary into a distdict.dat, distdict.jmp

	if (dictionaryWriteRAOF!=NULL)
	{
		cerr << "Step 6: dump the 'distribution' dictionary..." << endl;
		cerr << "\tStoring " << dictionary.getCount() << " words into the distribution dictionary..." << endl;

		dictionary.forEachFreq(dumpDictionary);
		dictionary.clear();

		delete dictionaryWriteRAOF;
		dictionaryWriteRAOF=NULL;
	}


	// store the disttype.dat and disttype.jmp

	cerr << "\tStoring " << typeAltRecSet.getCount() << " types into the distribution type table..." << endl;

	typeAltRecSet.forEach(dumpTypeAltRecSet);
	typeAltRecSet.clear();

	// clean up

	cerr << "Step 7: Free some resources before indexing... " << endl; 

	if (badWordFile!=NULL)
	{
		delete badWordFile;
		badWordFile=NULL;
	}

	if (grammarFile!=NULL)
	{
		delete grammarFile;
		grammarFile=NULL;
	}

	if (dictionaryWriteRAOF!=NULL)
	{
		delete dictionaryWriteRAOF;
		dictionaryWriteRAOF=NULL;
	}

	if (typeWriteRAOF!=NULL)
	{
		delete typeWriteRAOF;
		typeWriteRAOF=NULL;
	}

	if (modelWriteRAOF!=NULL)
	{
		delete modelWriteRAOF;	
		modelWriteRAOF=NULL;
	}

	typeAltRecSet.clear();
	modelSet.clear();
	dictionary.clear();
	badWords.clear();

	// create the alternate index for the distdict table

	cerr << "Step 8: Create alternate index for dictionary table... " << endl; 

	if (outputDictPrefix.length()>0)
	{
		MTCcreateAltJmpRAOF < MTCdictAltRecord > makeDictIndex(outputDictPrefix + "dict");

		makeDictIndex.doIt();
	}
	else
	{
		cerr << "\t\tNo dictionary created - skipping index step" << endl;
	}


	cerr << "That's all folks!" << endl;

	return 0;
}

// load the type alt records from the mstrtype.RAOF into a MTCRBTFreq
// return the typeIndex for BAD_CODE

long loadTypeAltRecords(MTCRBT <MTCtypeAltRecord> &typeAltRecSet, const MTCstring & aDictPrefix)
{
	// readRAOF as a typeAltRecord

	MTCreadRAOF <MTCtypeAltRecord> typeAltRecordReadRAOF("mstrtype");

	// "optimally" load all typeAltRecords from readRAOF into RBT

	MTCraofToRBT <MTCtypeAltRecord> typeAltRecordRAOFToRBT;

	typeAltRecordRAOFToRBT.doIt(typeAltRecordReadRAOF, typeAltRecSet);

	// clear the freqency of each typeAltRecord

	typeAltRecSet.forEach(clearTypeAltRecFreq);

	// look up and return the badTypeIndex

	MTCreadRAOF <MTCtypeRecord> typeRecordReadRAOF(aDictPrefix + "type");
	MTCtypeRecord temp;

	temp.setCode(BAD_CODE);
	typeRecordReadRAOF.find(temp);

	return typeRecordReadRAOF.getIndex();
}

void clearTypeAltRecFreq(MTCtypeAltRecord *aTypeAltRec)
{
	aTypeAltRec->setFreq(0);
}

const MTCstring removeNewLines(const MTCstring &aString)
{
	MTCstring output;

	for(int i=0; i<aString.length(); i++)
	{
		if (aString.c_str()[i]=='\n')
		{
			output+="n";
		}
		else if (aString.c_str()[i]!='\"')
		{
			if ((aString.c_str()[i]==' ')&&(i>0)&&(aString.c_str()[i-1]==' '))
			{
				break;
			}
			output+=aString.c_str()[i];
		}
	}

	return output; // +" ";
}

// dump the dictionary 

void dumpDictionary(MTCdictRecord *aDictRec, long freq)
{
	aDictRec->setFreq(freq);
	dictionaryWriteRAOF->append(*aDictRec);
}

void dumpTypeAltRecSet(MTCtypeAltRecord *aTypeAltRec)
{
	if (typeWriteRAOF!=NULL)
	{
		typeWriteRAOF->append(*aTypeAltRec);
	}
}

void dumpModelSet(MTCsentenceModel *aModel, long freq)
{
	static BOOL firstRule=TRUE;

	aModel->setFreq(freq);

	if (modelWriteRAOF!=NULL)
	{
		modelWriteRAOF->append(aModel);
	}

	long answer;
	MTCtypeAltRecord tempTypeAltRecord;
	MTCtypeAltRecord *foundTypeAltRec;

	if (grammarFile!=NULL)
	{
		if (firstRule==TRUE)
		{
			firstRule=FALSE;
			*grammarFile << "\t\t";
		}
		else
		{
			*grammarFile << "\t|\t";
		}

		do 
		{
			do
			{
				MTCstring punctuation;
				answer=aModel->getNext(&punctuation);
	
				if (punctuation.length()>0)
				{
					*grammarFile << "{" << punctuation << "} ";
				}
			} while (answer==SENTMDL_MORE_PUNCT);

			if (answer!=SENTMDL_GETNEXT_DONE)
			{
				tempTypeAltRecord.setIndex(answer);

				if ((foundTypeAltRec=typeAltRecSet.find(tempTypeAltRecord))==NULL)
				{
					errorMsg(EMT_ERROR, "I could not find a type index.  The grammar definition file may be incompleted", "dumpModelSet()"); 
				}
				else
				{
					*grammarFile << foundTypeAltRec->getCode() << ' ';
				}
			}
		} while (answer!=SENTMDL_GETNEXT_DONE);

		*grammarFile << '@@' << aModel->getFreq() << endl;
	}
}

void dumpBadWords(MTCstring *str)
{
	if (badWordFile!=NULL)
	{
		*badWordFile << *str << endl;
	}
}

void usage()
{
	cerr << "Usage: genmodel [-s] [-d inputDictionaryPrefix] [-i inputFile] [-j jumpOverFirstLineCount] [-b badWordFile] [-g outputGrammarFile] [-o outputDictionaryPrefix] [-m outputModelPrefix] [[-u updateFreq] | [-q]]" << endl;
 
	cerr << "\t-s\tDo not load tables into RAM -- read it as needed from disk" << endl;
	cerr << "\t-d\tinput dictionary prefix (default: mstr)" << endl;	
	cerr << "\t-i\tinput file (default: stdin)" << endl;
	cerr << "\t-j\tjump over (ignore) this number of lines at start of input" << endl; 
	cerr << "\t-b\toutput list of words not found in input dictionary" << endl; 
	cerr << "\t-g\toutput a (probably useless) grammar with 1 big rule" << endl;
	cerr << "\t-m\toutput a sentence model table with this prefix (default: dist or -o)" << endl;
	cerr << "\t-o\toutput a dictionary table with this prefix (default: dist)" << endl;
	cerr << "\t-u\tprint updates after processing this many models" << endl;
	cerr << "\t-q\tquiet - same as -u 0" << endl;
	cerr << endl;
	cerr << "The statistics output during processing are:" << endl;
	cerr << "\tSR:\tNumber of Sentences Read" << endl;
	cerr << "\tUS:\tNumber of Unique Sentences Read" << endl;
	cerr << "\tWR:\tNumber of Words Read" << endl;
	cerr << "\tUW:\tNumber of Unique Words Read" << endl;
	cerr << "\tBWR:\tNumber of Bad Words Read (not in dictionary)" << endl;
	cerr << "\tUBW:\tNumber of Unique Bad Words Read" << endl;
}

void printStats()
{
	cerr << "\rSR: " << modelCounter << " US: " << modelSet.getCount() << " WR: " << wordCounter << " UW: " << dictionary.getCount() << " BWR: " << badWordCounter << " UBW: " << badWords.getCount() << "        \r";  
}
@


1.26
log
@Changed yy* to zz* to avoid multiple symbols for LEX parsers
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.25 1997/05/03 16:16:59 markc Exp markc $
d8 3
d15 1
a15 1
 * Added static char rcsid []  = "@@(#)$Id: genmodel.cc,v 1.25 1997/05/03 16:16:59 markc Exp markc $";
d95 1
a95 1
static char rcsid []  = "@@(#)$Id: genmodel.cc,v 1.25 1997/05/03 16:16:59 markc Exp markc $";
d121 1
a122 11
MTCRBT <MTCtypeAltRecord> typeAltRecSet;

MTCRBTFreq <MTCdictRecord> dictionary;	// new dictionary 
MTCwriteRAOF <MTCdictRecord>     * dictionaryWriteRAOF;
MTCwriteRAOF <MTCsentenceModel>  modelWriteRAOF ("mstrmodel");
MTCwriteRAOF <MTCtypeAltRecord>  typeWriteRAOF ("disttype");
ofstream rulesFile("grambase.def");
BOOL firstRule=TRUE;
ofstream badWordFile("badword.out");
MTCRBT <MTCstring> badWords;
MTCRBTFreq <MTCsentenceModel> modelSet;
d130 1
a130 1
long loadTypeAltRecords(MTCRBT <MTCtypeAltRecord> &);
d140 9
a148 2
long bitIndex=0;
long lastTypeIndex=-444;
d153 9
d163 1
a163 1
	if (argc!=1)
d165 1
a165 1
		if (argc==2)
d167 118
a284 9
			if (strcmp(argv[1],"-s")==0)
			{
				smallMode=TRUE;
			}
			else
			{
				usage();	
				return -1;
			}
d286 8
a293 1
		else
d295 3
a297 2
			usage();
			return -1;
d302 1
a302 1
	MTCreadRAOF <MTCdictRecord> dictRecordReadRAOF ("mstrdict");
d317 2
d320 1
a320 1
	cerr << "Sentence Model Analysis Started..." << endl;
d322 1
a322 1
	// load type alternate records
d324 1
a324 1
	cerr << "Step 1: Loading type information from master table..." << endl;
d326 1
a326 1
	badTypeIndex=loadTypeAltRecords(typeAltRecSet);
d328 1
a328 3
	cerr << "Step 2: Loading Dictionary..." << endl;

	if (smallMode==TRUE)
a329 5
		cerr << "\tsmall memory mode [-s] selected -- I will not load it into RAM" << endl;
	}
	else
	{
		cerr << "\treading whole table into RAM -- If I run out of memory, try [-s]" << endl;
d427 2
a428 2
					MTCstring bad(currentDictRec.getValue());
					badWords.add(bad);
d430 11
a440 2
					currentDictRec.setTypeIndex(badTypeIndex);
					good=FALSE;
a487 4
#ifdef ADD_PUNCTUATION_TO_DICTIONARY
				currentDictRec.setTypeIndex(-1);
				dictionary.add(currentDictRec);
#endif
d498 3
a500 1
				if ((++modelCounter%32)==0)
a507 8
			case PUNCTUATION: 	
#ifdef ADD_PUNCTUATION_TO_DICTIONARY
				currentDictRec.setTypeIndex(-1);
				dictionary.add(currentDictRec);
				sprintf(buffer, "%ld ", currentDictRec.getTypeIndex());
					
				bufferString=buffer;
				model+=bufferString+currentDictRec.getValue()+"p;";
d509 1
a509 1
#else
a510 1
#endif
d530 1
a530 1
	cerr << "Step 4: Output badwords.out file" << endl;
d532 1
a532 1
	if (badWordCounter>0)
d534 1
a534 4
		cerr << "\tWarning: " << badWordCounter << " instances of undefined words." << endl;
		cerr << "\t         " << badWords.getCount() << " unique undefined words." << endl; 
		cerr << "\t          Please see badword.out file" << endl;
		badWords.forEach(dumpBadWords);
d538 7
a544 1
		cerr << "\tAll words in sample texts were defined! " << endl;
d550 1
d553 22
a574 4
	rulesFile << "// rules generated by genmodel" << endl;
	rulesFile << "// these should match mstrmodel.dat" << endl;
	rulesFile << endl;
	rulesFile << "SENTENCE:" << endl;
a575 1
	modelSet.forEachFreq(dumpModelSet);
a577 3
	rulesFile << "\t;" << endl;
	rulesFile << endl;

d580 4
a583 2
	cerr << "Step 6: Dump the 'distribution' dictionary..." << endl;
	cerr << "\tStoring " << dictionary.getCount() << " words into the distribution dictionary..." << endl;
d585 2
a586 1
	dictionaryWriteRAOF= new MTCwriteRAOF <MTCdictRecord> ("distdict");
d588 2
a589 4
	if (dictionaryWriteRAOF==NULL)
	{
		cerr << "I could not allocate a dictionary write object" << endl;
		exit (-1);
a591 5
	dictionary.forEachFreq(dumpDictionary);
	dictionary.clear();

	delete dictionaryWriteRAOF;
	dictionaryWriteRAOF=NULL;
d600 39
d641 1
a641 1
	cerr << "Step 7: Creating alternate index for dictionary table... " << endl; 
d643 10
a652 1
	MTCcreateAltJmpRAOF < MTCdictAltRecord > makeDictIndex("distdict");
a653 1
	makeDictIndex.doIt();
d663 1
a663 1
long loadTypeAltRecords(MTCRBT <MTCtypeAltRecord> &typeAltRecSet)
d681 1
a681 1
	MTCreadRAOF <MTCtypeRecord> typeRecordReadRAOF("mstrtype");
d728 4
a731 1
	typeWriteRAOF.append(*aTypeAltRec);
d736 2
d740 1
a740 3
	modelWriteRAOF.append(aModel);

	if (firstRule==TRUE)
d742 1
a742 6
		firstRule=FALSE;
		rulesFile << "\t\t";
	}
	else
	{
		rulesFile << "\t|\t";
d749 1
a749 1
	do 
d751 6
a756 1
		do
d758 2
a759 2
			MTCstring punctuation;
			answer=aModel->getNext(&punctuation);
d761 3
a763 1
			if (punctuation.length()>0)
d765 8
a772 3
				rulesFile << "{" << punctuation << "} ";
			}
		} while (answer==SENTMDL_MORE_PUNCT);
d774 3
a776 3
		if (answer!=SENTMDL_GETNEXT_DONE)
		{
			tempTypeAltRecord.setIndex(answer);
d778 8
a785 7
			if ((foundTypeAltRec=typeAltRecSet.find(tempTypeAltRecord))==NULL)
			{
				errorMsg(EMT_ERROR, "I could not find a type index.  The grammar definition file may be incompleted", "dumpModelSet()"); 
			}
			else
			{
				rulesFile << foundTypeAltRec->getCode() << ' ';
d787 1
a787 2
		}
	} while (answer!=SENTMDL_GETNEXT_DONE);
d789 2
a790 1
	rulesFile << '@@' << aModel->getFreq() << endl;
d795 4
a798 1
	badWordFile << *str << endl;
d803 12
a814 2
	cerr << "Usage: genmodel [-s]" << endl;
	cerr << "\t-s\tDo not load mstrdict into RAM -- read it as needed from disk" << endl;
@


1.25
log
@Added statis doc to usage()
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.24 1997/03/05 17:41:20 markc Exp markc $
d8 3
d12 1
a12 1
 * Added static char rcsid []  = "@@(#)$Id$";
d92 1
a92 1
static char rcsid []  = "@@(#)$Id: genmodel.cc,v 1.24 1997/03/05 17:41:20 markc Exp markc $";
d116 2
a117 2
int yylex();
extern char *yytext;
d182 1
a182 1
	MTCstring yytextString;
d228 1
a228 1
		retval=yylex();		// read the next token from stdin
d230 1
a230 1
		if (yytext[0]=='\0')	// is it eof?
d235 2
a236 2
		yytextString=yytext;
		yytextString.toLower();	// everything lower case for now...
d238 1
a238 1
		currentDictRec.setValue(yytextString);
d247 1
a247 1
				if ((yytext[0]>='A')&&(yytext[0]<='Z'))
d249 1
a249 1
					MTCstring tstr(yytext);
d253 1
a253 1
					if (tstr==yytext)
@


1.24
log
@Added static char rcsid []  = "@@(#)$Id$";
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.23 1997/03/02 04:45:46 markc Exp markc $
d8 3
d89 1
a89 1
static char rcsid []  = "@@(#)$Id$";
d608 8
@


1.23
log
@Big changes: [-s] added, printStats, SENTMDL_CAP*, capWord fixed, usage()
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.22 1997/02/16 06:57:12 markc Exp markc $
d8 3
d85 2
@


1.22
log
@BST replaced with RBT
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.21 1996/02/20 03:44:23 markc Exp markc $
d8 3
d117 8
d139 1
a139 1
int main()
d141 23
d166 1
a171 1
	MTCRBTFreq <MTCsentenceModel> modelSet;
a178 2
	MTCRBT <MTCstring> badWords;
	long badWordCount=0;
d185 1
a185 1
	cerr << "Loading type information from master table..." << endl;
d189 20
d211 1
a211 1
	cerr << "Scanning sentences from stdin..." << endl;
d234 2
d238 2
a239 1
					MTCstring tstr(yytextString);
d241 2
a242 1
					if (tstr==yytextString)
a243 1
						model.appendPunctuation("cap");
d248 1
a248 1
						model.appendPunctuation("shift");
d263 5
d269 6
d280 8
a287 1
				found=dictRecordReadRAOF.find(currentDictRec);
d297 1
a297 1
					badWordCount++;
d329 5
d340 1
a340 1
					model.appendPunctuation("low");
d343 1
d361 5
d384 12
d397 1
d400 3
a402 1
	if (badWordCount>0)
d404 1
a404 1
		cerr << "\tWarning: " << badWordCount << " instances of undefined words." << endl;
d409 4
d416 2
a417 1
	cerr << "Storing " << modelSet.getCount() << " Models..." << endl;
d432 2
a433 1
	cerr << "Storing " << dictionary.getCount() << " words into the distribution dictionary..." << endl;
d451 1
a451 1
	cerr << "Storing " << typeAltRecSet.getCount() << " types into the distribution type table..." << endl;
d458 1
a458 1
	cerr << "Creating alternate index for dictionary table... " << endl; 
d594 11
@


1.21
log
@*** empty log message ***
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.20 1996/02/17 18:46:13 markc Exp markc $
d8 3
d26 1
a26 1
// replaced BST with RBT for dicitonary
a88 1
#include "../../mtc++/include/bst.h"
d92 1
a92 1
#include "../../mtc++/include/raof2bst.h"
d105 1
a105 1
MTCBST <MTCtypeAltRecord> typeAltRecSet;
d107 1
a107 1
MTCBSTFreq <MTCdictRecord> dictionary;	// new dictionary 
d115 1
a115 1
long loadTypeAltRecords(MTCBST <MTCtypeAltRecord> &);
d137 1
a137 1
	MTCBSTFreq <MTCsentenceModel> modelSet;
d364 1
a364 1
// load the type alt records from the mstrtype.RAOF into a MTCBSTFreq
d367 1
a367 1
long loadTypeAltRecords(MTCBST <MTCtypeAltRecord> &typeAltRecSet)
d373 1
a373 1
	// "optimally" load all typeAltRecords from readRAOF into BST
d375 1
a375 1
	MTCraofToBST <MTCtypeAltRecord> typeAltRecordRAOFToBST;
d377 1
a377 1
	typeAltRecordRAOFToBST.doIt(typeAltRecordReadRAOF, typeAltRecSet);
@


1.20
log
@use freq for dictrecords
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.19 1996/02/17 16:42:31 markc Exp markc $
d8 3
d201 2
a202 1
					dictionary.add(*found, FALSE);
d405 1
a405 1
			output+=" n ";
d409 4
d417 1
a417 1
	return output+" ";
@


1.19
log
@added grambase.def generation automatically
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.18 1996/02/14 15:07:31 markc Exp markc $
d8 3
d102 1
a102 1
MTCRBT <MTCdictRecord> dictionary;	// new dictionary 
d108 1
d114 1
a114 1
void dumpDictionary(MTCdictRecord *);
d117 1
d140 1
a140 1
	ofstream badWordFile("badword.out");
a196 1
					// SOME DAY...
d198 1
a198 1
					// dictionary.add(*found, FALSE);
d216 2
a217 1
					badWordFile << currentDictRec.getValue() << endl;
d297 7
a303 1
	cerr << "Warning: " << badWordCount << " instances of bad words were encountered.  Please see badword.out file" << endl;
d332 1
a332 1
	dictionary.forEach(dumpDictionary);
d414 1
a414 1
void dumpDictionary(MTCdictRecord *aDictRec)
d416 1
d476 4
@


1.18
log
@use shift and cap
ignore quotation marks
output mstrmodel instead of model
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.17 1996/02/07 04:02:19 markc Exp markc $
d8 5
d103 2
d298 5
d306 3
d418 44
@


1.17
log
@removed #include "rbt.h" -- duplicate -- only needed once ;)
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.16 1996/01/20 18:18:47 markc Exp markc $
d8 3
d96 1
a96 1
MTCwriteRAOF <MTCsentenceModel>  modelWriteRAOF ("model");
d130 1
d163 17
d239 8
d377 1
a377 1
		else
@


1.16
log
@replaced BST with RBT for dicitonary
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.15 1996/01/20 17:23:28 markc Exp markc $
d8 3
a72 1
#include "../../mtc++/include/rbt.h"
@


1.15
log
@use rbt version of raofalt instead of bst
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.14 1996/01/13 09:45:52 markc Exp markc $
d8 3
d70 1
d89 1
a89 1
MTCBST <MTCdictRecord> dictionary;	// new dictionary 
@


1.14
log
@removed cout << Model
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.13 1996/01/13 09:41:29 markc Exp markc $
d8 3
d65 1
@


1.13
log
@use new sentnode enabled sentmdl
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.12 1995/11/12 23:04:28 chapman Exp markc $
d8 3
a160 2
					cout << "Model: " << model << endl;

a207 2
				cout << "Model: " << model << endl;

a219 1
					cout << "Model: " << model << endl;
a238 1
				cout << "Model: " << model << endl;
@


1.12
log
@Converted to use the .alt files and everything
it actually works now.
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.11 1995/11/08 19:40:58 chapman Exp chapman $
d8 4
d69 1
d157 2
a158 1
					model.append(found->getTypeIndex());
d206 2
a207 1
				model.append(currentDictRec.getTypeIndex());
d220 2
a221 1
					model.append(removeNewLines(currentDictRec.getValue()));
d240 2
a241 1
				model.append(removeNewLines(currentDictRec.getValue()));
@


1.11
log
@Removed #include "dictent.h"
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.10 1995/11/08 19:25:10 chapman Exp chapman $
d8 3
d58 2
d63 1
d71 9
a79 6
MTCBST <MTCdictRecord> dictionary;
MTCBSTFreq <long> typeFreqSet;
MTCBST <MTCdictAltRecord> distDict;  
MTCwriteRAOF <MTCdictAltRecord>       writeRAOF ("distdict");
MTCwriteRAOF <MTCsentenceModel>  modelRAOF ("model");
MTCwriteRAOF <long>              distTypeRAOF ("disttype", NEEDS_EOL);  
d82 1
a82 1
void dumpDistDict(MTCdictAltRecord *);
d84 1
a84 1
void dumpTypeFreqSet(long *, long);
d93 4
a96 3
	MTCreadRAOF <MTCdictRecord> dictRecord ("mstrdict");
	MTCreadRAOF <MTCtypeRecord> mstrType ("mstrtype");
	MTCdictRecord current;
a100 1
	MTCtypeRecord tempType;
d106 7
d114 1
a114 1
	// set the badTypeIndex
d116 1
a116 3
	tempType.setCode(BAD_CODE);
	mstrType.find(tempType);
	badTypeIndex=mstrType.getIndex();
d118 1
a118 1
	// scan and process each word from stdin
d120 1
a120 1
	cerr << "Reading Words..." << endl;
d126 1
a126 1
		retval=yylex();
d128 2
a129 1
		if (yytext[0]=='\0')
d131 1
d134 1
a134 1
		yytextString.toLower();
d136 1
a136 1
		current.setValue(yytextString);
d141 44
a184 1
						found=dictRecord.find(current);
d186 13
a198 13
						if (found)
						{
							current.setTypeIndex(found->getTypeIndex());
							dictionary.add(current);

							model.append(current.getTypeIndex());
						}
						else
						{
							cerr << '\"' << current.getValue() << "\" was not in master dictionary, sentence model rejected." << endl; 
							current.setTypeIndex(badTypeIndex);
							good=FALSE;
						}
d200 3
a202 1
						break;
d206 2
a207 2
						current.setTypeIndex(-1);
						dictionary.add(current);
d209 13
a221 9
						if (good==TRUE)
						{
						//	model.append(current.getTypeIndex());
							model.append(removeNewLines(current.getValue()));
							modelSet.add(model);
						}
						model.clear();
						good=TRUE;
						break;
d224 6
a229 6
						current.setTypeIndex(-1);
						dictionary.add(current);
						sprintf(buffer, "%ld ", current.getTypeIndex());
							
						bufferString=buffer;
						model+=bufferString+current.getValue()+"p;";
d232 1
a232 1
						model.append(removeNewLines(current.getValue()));
d234 1
a234 1
						break;
d238 3
a240 2
	cerr << "Sorting " << dictionary.getCount() << " words in the Dictionary..." << endl;
	dictionary.forEach(createDistDict);
d242 1
a242 2
	cerr << "Clearing Dictionary" << endl;
	dictionary.clear();
d244 1
a244 2
	cerr << "Dumping Distribution Dictionary..." << endl;
	distDict.forEach(dumpDistDict);
a245 1
	cerr << "Dumping Model Set..." << endl;
d247 5
d253 3
a255 2
	cerr << "Dumping Type Set..." << endl;
	for(long i=0; i<mstrType.getCount(); i++)
d257 2
a258 1
		typeFreqSet.add(i);
d260 21
a280 1
	typeFreqSet.forEachFreq(dumpTypeFreqSet);
d287 35
d329 1
d331 1
d333 1
d335 1
d341 1
a341 3
void createDistDict(MTCdictRecord *aMstrDict)
{
	MTCdictAltRecord tempDict;
d343 1
a343 9
	tempDict.setValue(aMstrDict->getValue());
	tempDict.setTypeIndex(aMstrDict->getTypeIndex());

	tempDict.setBitString(bitIndex++);

	distDict.add(tempDict);
}
	
void dumpDistDict(MTCdictAltRecord *aDistDict)
d345 1
a345 18
	// dump dictionary into writeRAOF

	MTCdictAltRecord tempDict(*aDistDict);

	if (tempDict.getTypeIndex()!=lastTypeIndex)
	{
		bitIndex=0;
	}

	lastTypeIndex=tempDict.getTypeIndex();

	tempDict.setBitString(bitIndex++);

	writeRAOF.append(tempDict);

	// add type to typeFreqSet

	typeFreqSet.add(lastTypeIndex);
d348 1
a348 1
void dumpTypeFreqSet(long *, long freq)
d350 1
a350 1
	distTypeRAOF.append(--freq);
d357 1
a357 1
	modelRAOF.append(aModel);
@


1.10
log
@Compiled with new "records" instead of "mstr*"
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.9 1995/10/12 16:04:46 markc Exp chapman $
d8 3
d18 1
a18 1
// update 
a51 1
#include "../include/dictent.h"
@


1.9
log
@Fixed the repeat-last-type-when-end-of-sentence bug./
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.8 1995/09/25 03:10:22 markc Exp markc $
d8 3
d54 3
a56 3
#include "../include/mstrdict.h"
#include "../include/mstrtype.h"
#include "../include/distdict.h"
d63 1
a63 1
MTCBST <MTCmstrDict> dictionary;
d65 2
a66 2
MTCBST <MTCdistDict> distDict;  
MTCwriteRAOF <MTCdistDict>       writeRAOF ("distdict");
d70 2
a71 2
void createDistDict(MTCmstrDict *);
void dumpDistDict(MTCdistDict *);
d82 3
a84 3
	MTCreadRAOF <MTCmstrDict> mstrDict ("mstrdict");
	MTCreadRAOF <MTCmstrType> mstrType ("mstrtype");
	MTCmstrDict current;
d89 3
a91 3
	MTCmstrType tempType;
	MTCmstrDict find;
	const MTCmstrDict *found;
d123 1
a123 1
						found=mstrDict.find(current);
d210 1
a210 1
void createDistDict(MTCmstrDict *aMstrDict)
d212 1
a212 1
	MTCdistDict tempDict;
d222 1
a222 1
void dumpDistDict(MTCdistDict *aDistDict)
d226 1
a226 1
	MTCdistDict tempDict(*aDistDict);
@


1.8
log
@Check It In -- thank you.
@
text
@a0 1
//#define DEBUG
d5 1
a5 1
 * $Id: genmodel.cc,v 1.7 1995/08/24 20:13:47 markc Exp root $
d8 3
d131 1
a131 1
							cout << current.getValue() << endl; 
d145 1
a145 1
							model.append(current.getTypeIndex());
@


1.7
log
@update 

it now works well with babble 1.1
@
text
@d1 1
d6 1
a6 1
 * $Id: genmodel.cc,v 1.6 1995/08/24 18:32:59 markc Exp markc $
d9 5
d76 1
d101 2
d121 1
d123 4
d128 2
d131 2
a133 3
						dictionary.add(current);

						model.append(current.getTypeIndex());
d141 6
a146 3
						model.append(current.getTypeIndex());
						model.append(removeNewLines(current.getValue()));
						modelSet.add(model);
d148 1
@


1.6
log
@Use sentenceModel class instead of just an array of strings for Model
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.5 1995/08/24 02:02:27 markc Exp markc $
d8 3
d193 1
a193 5
	char buffer[20];

	sprintf(buffer, "%ld", bitIndex++);

	tempDict.setBitstring(buffer);
d211 1
a211 5
	char buffer[20];

	sprintf(buffer, "%ld", bitIndex++);

	tempDict.setBitstring(buffer);
@


1.5
log
@Revised Model, added MARK_'s,
Next I need to optimize the sentence model format.
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.4 1995/08/24 01:02:51 markc Exp markc $
d8 4
d43 1
d52 3
a54 3
MTCwriteRAOF <MTCdistDict> writeRAOF ("distdict");
MTCwriteRAOF <MTCstring>   modelRAOF ("model", NEEDS_EOL);  
MTCwriteRAOF <long>        distTypeRAOF ("disttype", NEEDS_EOL);  
d58 1
a58 1
void dumpModelSet(MTCstring *, long);
d60 1
d72 2
a73 2
	MTCBSTFreq <MTCstring> modelSet;
	MTCstring model;
d115 1
a115 3
						sprintf(buffer, "%ld ", current.getTypeIndex());
						bufferString=buffer;
						model+=bufferString;
a118 11
						{
						MTCstring endp;
						const char *ptr=current.getValue().c_str();
						for(int i=0; i<strlen(ptr); i++)
						{
							if (ptr[i]=='\n')
								endp+='n';
							else
								endp+=ptr[i];
						}

d123 2
a124 4

						sprintf(buffer, "%ld ", current.getTypeIndex());
						bufferString=buffer;
						model+=bufferString+endp+MARK_END_OF_PUNCT;
d126 1
a126 2
						model="";
						}
d138 1
a138 1
						model+=current.getValue()+"p;";
d168 15
d230 1
a230 1
void dumpModelSet(MTCstring *aString, long freq)
d232 1
a232 6
	MTCstring tempString(*aString);

	tempString+=MARK_END_OF_SENTENCE;

	char buffer[20];
	sprintf(buffer, " %ld", freq);
d234 1
a234 2
	tempString+=buffer;
	modelRAOF.append(tempString);
@


1.4
log
@Everything seems to work now -- needs clean-up though
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.3 1995/08/23 19:12:37 markc Exp markc $
d8 3
d53 1
a53 1
void dumpModelSet(MTCstring *);
d66 1
a66 1
	MTCBST <MTCstring> modelSet;
d126 1
d129 2
d133 1
a133 1
						model+=bufferString+endp+"p;";
d139 1
d146 4
d164 1
a164 1
	modelSet.forEach(dumpModelSet);
d225 1
a225 1
void dumpModelSet(MTCstring *aString)
d227 9
a235 1
	modelRAOF.append(*aString);
d237 1
@


1.3
log
@Correctly creates distdict.dat -- does not yet deal with disttype.dat
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.2 1995/08/14 01:01:54 markc Exp markc $
d8 3
d42 1
d45 2
a46 2
MTCwriteRAOF <MTCstring>  modelRAOF ("model", NEEDS_EOL);  
MTCwriteRAOF <MTCstring>  typeRAOF  ("type", NEEDS_EOL);  
d51 1
a51 1
void dumpTypeSet(MTCstring *);
a62 1
	MTCBST <MTCstring> typeSet;
a142 2
	typeSet.add(-1);

d146 3
d156 5
a160 1
	typeSet.forEach(dumpTypeSet);
d185 2
d203 4
d209 1
a209 1
void dumpTypeSet(MTCstring *aString)
d211 1
a211 1
	typeRAOF.append(*aString);
@


1.2
log
@In progress -- just back it up because it is kinda stable -- but wrong!
@
text
@d5 1
a5 1
 * $Id: genmodel.cc,v 1.1 1995/07/30 17:06:55 markc Exp markc $
d8 3
d38 2
a39 1
MTCBSTFreq <MTCdistDict> dictionary;
d44 2
a45 1
void dumpDictionary(MTCdistDict *);
d50 1
a50 1
long lastTypeIndex=0;
d56 1
a56 2
	MTCdistDict current;
	MTCmstrType tempType;
d62 1
d94 1
a94 2
						find.setValue(current.getValue());
						found=mstrDict.find(find);
a101 1
						cerr << "Added: " << current << endl;
d142 3
d146 1
a146 2

	dictionary.forEach(dumpDictionary);
a148 1

a151 1

d159 1
a159 1
void dumpDictionary(MTCdistDict *aDistDict)
d161 5
d168 12
a179 1
	if (aDistDict->getTypeIndex()!=lastTypeIndex)
d184 1
a184 1
	lastTypeIndex=aDistDict->getTypeIndex();
d186 3
a188 1
	sprintf(buffer, "%ld", bitIndex);
d190 3
a192 3
	aDistDict->setBitstring(buffer);
	
	writeRAOF.append(*aDistDict);
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 * $Id$
d7 4
a10 1
 * $Log$
d17 1
d27 4
d35 2
a36 4

MTCwriteRAOF <MTCstring> **writeRAOFarray;
MTCBST <MTCdictEnt> dictionary;
MTCwriteRAOF <MTCdictEnt> writeRAOF ("bye");
d40 1
a40 1
void dumpDictionary(MTCdictEnt *);
d43 3
a45 2
void makeTypeDicts();
void fillRAOFarray(MTCdictEnt *);
d49 5
d55 1
a55 1
	MTCBST <MTCstring> *typeSet=new MTCBST <MTCstring>;
d58 2
a59 3
	MTCreadRAOF <MTCdictEnt> readRAOF ("hello");
	MTCdictEnt current;
	const MTCdictEnt *found;
d61 12
d89 2
a90 1
						found=readRAOF.find(current);
d93 1
a93 1
							current.setCode(found->getCode());
d95 1
a95 1
							current.setCode("BAD");
d98 5
a102 2
						typeSet->add(current.getCode());
						model+=current.getCode()+";";
d117 1
a117 1
						current.setCode("PUNCT");
d119 3
a121 1
						model+=current.getCode()+endp+"p;";
d127 1
a127 1
						current.setCode("PUNCT");
d129 4
a132 1
						model+=current.getCode()+current.getValue()+"p;";
d137 3
a139 1
	typeSet->add("PUNCT");
d142 3
a145 1
	typeSet->forEach(dumpTypeSet);
d147 5
a151 1
//	makeTypeDicts();
d156 1
a156 1
void dumpDictionary(MTCdictEnt *aDict)
d158 14
a171 1
	writeRAOF.append(*aDict);
a182 39

/*
void fillRAOFarray(MTCdictEnt *aDictEnt)
{
	readTypeSet->find(aDictEnt->getCode());
	writeRAOFarray[readTypeSet->getIndex()]->append(aDictEnt->getValue());
}

void makeTypeDicts()
{
	readTypeSet = new MTCreadRAOF <MTCstring> ("type");
	writeRAOFarray= new MTCwriteRAOF <MTCstring> *[readTypeSet->getCount()];

	MTCstring name;
	int i;

	// allocate the array

	cout << "count: " << readTypeSet->getCount() << endl;

	for(i=0; i<readTypeSet->getCount(); i++)
	{
		name=*readTypeSet->read(i);
		writeRAOFarray[i]=new MTCwriteRAOF <MTCstring> (name,NEEDS_EOL);
		cout << "Name: " << i << name << endl;
	}
	
	dictionary.forEach(fillRAOFarray);

	// clean up

	for(i=0; i<readTypeSet->getCount(); i++)
	{
		delete writeRAOFarray[i];
	}

	delete [] writeRAOFarray; 
}
*/
@
