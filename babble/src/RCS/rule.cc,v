head	1.8;
access;
symbols;
locks; strict;
comment	@// @;


1.8
date	97.02.24.00.12.19;	author markc;	state Exp;
branches;
next	1.7;

1.7
date	96.01.13.12.00.33;	author markc;	state Exp;
branches;
next	1.6;

1.6
date	96.01.13.10.18.10;	author markc;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.23.48.19;	author markc;	state Exp;
branches;
next	1.4;

1.4
date	96.01.10.22.15.49;	author markc;	state Exp;
branches;
next	1.3;

1.3
date	96.01.10.20.41.59;	author markc;	state Exp;
branches;
next	1.2;

1.2
date	96.01.08.21.54.42;	author markc;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.17.32.38;	author markc;	state Exp;
branches;
next	;


desc
@initial check in
@


1.8
log
@Added printStats and fixed maxModelLength
@
text
@/*
 * Grammar Rules
 * Copyright (c) Mark T. Chapman 1995
 *
 * $Id: rule.cc,v 1.7 1996/01/13 12:00:33 markc Exp markc $
 *
 * $Log: rule.cc,v $
 * Revision 1.7  1996/01/13 12:00:33  markc
 * added punctuation processing to grammar definition language using {}
 *
// Revision 1.6  1996/01/13  10:18:10  markc
// use new sentnode enabled sentence models
//
// Revision 1.5  1996/01/12  23:48:19  markc
// dynamic grammars work system wide -- next step, constant expressions
//
// Revision 1.4  1996/01/10  22:15:49  markc
// makeModel() works
//
// Revision 1.3  1996/01/10  20:41:59  markc
// correctly parses and sets up grammar rules -- does not yet makeModel()
//
// Revision 1.2  1996/01/08  21:54:42  markc
// not quite ready
//
// Revision 1.1  1996/01/08  17:32:38  markc
// Initial revision
//
 *
 */

static char rcsid []  = "@@(#)$Id: rule.cc,v 1.7 1996/01/13 12:00:33 markc Exp markc $";

#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include "../../mtc++/include/MTC++.h"
#include "../../mtc++/include/mstring.h"
#include "../../mtc++/include/errormsg.h"
#include "../../mtc++/include/list.h"
#include "../../gendict/include/sentnode.h"
#include "../../gendict/include/sentmdl.h"
#include "../include/rule.h"

// constructor
MTCrule::MTCrule()
	: 	name("UNDEFINED_RULE"), terminal(-1), totalWeight(0), 
		rhs(NULL), allPunct(FALSE), isPunct(FALSE)
{
	init();

	return;
}

// parameterized constructor

MTCrule::MTCrule(const MTCstring &s)
	: 	name(s), terminal(-1), totalWeight(0),
		rhs(NULL), allPunct(FALSE), isPunct(FALSE)
{
	init();

	return;
}

// copy constructor

MTCrule::MTCrule(MTCrule &r)
{
	init(r);
	
	return;
}

// shared constructor code

void MTCrule::init()
{
	if ((rhs=new MTClist <MTCruleRHS>)==NULL)
	{
		errorMsg(EMT_ABORT, "I do not have enough memory to allocate a MTClist of MTCruleRHS's", "MTCrule::init()");
		return;
	}
}

// shared constructor and operator=() code

void MTCrule::init(MTCrule &r)
{
	if (r.rhs==NULL)
	{
		errorMsg(EMT_WARNING, "Why did I just copy an MTCrule with a NULL rhs?", "MTCrule::operator=()");
		rhs=NULL;
	}
	else
	{
		if ((rhs=new MTClist <MTCruleRHS>(*r.rhs))==NULL)
		{
			errorMsg(EMT_ABORT, "I do not have enough memory to allocate a MTClist of MTCruleRHS's", "MTCrule::init()");
			return;
		}
	}

	name=r.name;
	terminal=r.terminal;
	totalWeight=r.totalWeight;
	allPunct=r.allPunct;
	isPunct=r.isPunct;
}

// destructor

MTCrule::~MTCrule()
{
	if (rhs!=NULL)
	{
		delete rhs;
		rhs=NULL;
	}

	return;
}

// clear the rule

void MTCrule::clear()
{ 
	name=""; 
	nextRHS.clear(); 
	terminal=-1; 
	totalWeight=0; 

	if (rhs!=NULL)
	{
		rhs->clear(); 
	}
}

// commit the nextRHS to this rule

void MTCrule::commitRHSSet(unsigned long w)
{ 
	totalWeight+=w;
	nextRHS.setWeight(totalWeight);

	if (rhs==NULL)
	{
		errorMsg(EMT_WARNING, "I cannot commit a RHSSet to a rule with a NULL MTClist <MTCruleRHS> *rhs", "MTCrule::commitRHSSet()");
	}
	else
	{
		rhs->add(nextRHS); 
	}

	nextRHS.clear(); 
};

// < comparison

int MTCrule::isLessThan(const MTCrule & aSrc) const
{
	return (name<aSrc.name);
}

// equivalence test

int MTCrule::isEqual(const MTCrule & aSrc) const
{
	return (name==aSrc.name);
}

// == operator

BOOL MTCrule::operator==(const MTCrule & aSrc) const
{
	return (isEqual(aSrc));
}

// != operator

BOOL MTCrule::operator!=(const MTCrule & aSrc) const
{
	return (!isEqual(aSrc));
}

//  < operator

BOOL MTCrule::operator<(const MTCrule & aSrc)  const
{
	return (isLessThan(aSrc));
}

//  <= operator

BOOL MTCrule::operator<=(const MTCrule & aSrc) const
{
	return (isLessThan(aSrc)||isEqual(aSrc));
}

//  > operator

BOOL MTCrule::operator>(const MTCrule & aSrc)  const
{
	return (!(isLessThan(aSrc)||(isEqual(aSrc))));
}

//  >= operator

BOOL MTCrule::operator>=(const MTCrule & aSrc) const
{
	return (!(isLessThan(aSrc)));
}

// stream insertor operators -- used to dump rules only!!

ostream & operator<<(ostream &s, MTCruleRHS &r)
{
	for(int i=0; i<=r.max; i++)
	{
		if (r.rules[i]!=NULL)
		{
			s << r.rules[i]->getName() << ' ';
		}
	}

	s << '#' << r.weight;

	return s;
}

ostream & operator<<(ostream &s, MTCrule &r)
{
	if (r.getIsPunct()==TRUE)
	{
		s << r.name << ": (punctuation rule only) ;" << endl << endl;
	}
	else
	{
		MTCstring delimeter="\t \t";

		s << r.name << ": " << endl;

		if (r.rhs==NULL)
		{
			s << "* * * * * THIS RULE'S RHS IS A NULL MTClist <MTCruleRHS> * ";
		}
		else
		{
			if (r.rhs->getCount()==0)
			{
				s << "\t\tterminal(" << r.getTerminal() << ")" << endl; 
			}
			else
			{
				for(MTCruleRHS *trhs=r.rhs->getFirst(); trhs!=NULL; trhs=r.rhs->getNext())
				{
					s << delimeter;
					s << *trhs << endl;
					delimeter="\t|\t";
				}
			}
		}

		s << "\t;" << endl << endl;
	}

	return s;
}

// overloaded = operator

MTCrule & MTCrule::operator=(MTCrule &aSrc)
{
	init(aSrc);

	return *this;
}

// default constructor 

MTCruleRHS::MTCruleRHS() : max(-1), weight(1) 
{ 
	for(int i=0; i<MAX_RULE_RHS; i++) 
	{
		rules[i]=NULL; 
	}

	return;
}

// copy constructor

MTCruleRHS::MTCruleRHS(const MTCruleRHS &s) : max(s.max), weight(s.weight)
{ 
	for(int i=0; i<MAX_RULE_RHS; i++) 
	{
		rules[i]=s.rules[i]; 
	}
}

// destructor

MTCruleRHS::~MTCruleRHS() 
{ 
	return; 
}

// clear the current rule rhs
void MTCruleRHS::clear()	
{ 	
	max=-1; 
	current=-1; 
	weight=1;

	for(int i=0; i<MAX_RULE_RHS; i++) 
	{
		rules[i]=NULL;
	}
}

// return the next RHS of the ruleRHS

MTCrule * MTCruleRHS::getNextRHS()   
{ 
	if ((++current)<=max) 
	{
		return rules[current]; 
	}

	return NULL; 
}
	
// get the RHSSet count

long MTCrule::getRHSSetCount() const
{
	if (rhs==NULL)
	{
		errorMsg(EMT_WARNING, "I cannot return the count of the NULL rhs -- I will return 0 instead", "MTCrule::getRHSSetCount()");
		return 0;
	}

	return rhs->getCount();
}

// overloaded assignment operator

const MTCruleRHS & MTCruleRHS::operator=(const MTCruleRHS &s)
{ 
	max=s.max; 
	weight=s.weight;

	for(int i=0; i<MAX_RULE_RHS; i++) 
	{
		rules[i]=s.rules[i]; 
	}

	return *this;
}

// dummy comparison operator for use in list class

int MTCruleRHS::operator==(const MTCruleRHS &) const 
{ 
	return FALSE; 
}

// append a RHS to the ruleRHS

BOOL MTCruleRHS::appendRHS(MTCrule *r) 
{ 
	if (r==NULL) 
	{
		errorMsg(EMT_ERROR, "I cannot append a NULL rule to the RHS -- I will ignore it instead");
		return FALSE;
	}

	if ((max+1)<MAX_RULE_RHS)
	{
		rules[++max]=r;
		return TRUE;
	}
	else
	{
		errorMsg(EMT_WARNING, "I cannot handle that many RHS's for a rule.  Please adjust MAX_RULE_RHS in rules.h", "MTCruleRHS::appendRHS()");
		return FALSE;
	}
}

// make a sentence model from this rule set

void MTCrule::makeModel(MTCsentenceModel &model, int &maxSize)
{
	// check the facts, ma'am

	if (rhs==NULL)
	{
		errorMsg(EMT_WARNING, "I cannot add anything to a sentence model from a rule with no rhs list!", "MTCrule::makeModel()");
		return;
	}

	// is this a terminal?

	if (rhs->getCount()==0)
	{
		maxSize--;

		if ((terminal==-1)||(isPunct==TRUE)||(allPunct==TRUE))
		{
			model.appendPunctuation(name);
		}
		else
		{
			model.appendTypeIndex(terminal);
		}
	}
	else	// non-terminal -- use rhs to fill in model
	{
		MTCruleRHS *trhs=pickRHSSet();

		if (trhs==NULL)
		{
			errorMsg(EMT_WARNING, "I cannot add anything to a sentence model because I picked a NULL RHSSET!", "MTCrule::makeModel()");
			return;
		}

		for(MTCrule *tRule=trhs->getFirstRHS(); tRule!=NULL; tRule=trhs->getNextRHS())
		{
			tRule->makeModel(model, maxSize);

			// give up if we are already over the max size limit

			if (maxSize<0)
			{
				break;
			}
		}
	}

	return;
}

// pick a RHSSET from rhs randomly using weights -- used by makeModel()

MTCruleRHS * MTCrule::pickRHSSet()
{
	unsigned long randVal=random()%totalWeight;

	if (rhs==NULL)
	{
		errorMsg(EMT_WARNING, "I could not pick a RHSSet because the rule.rhs is NULL", "MTCrule::pickRHSSet()");
		return NULL;
	}

	for(MTCruleRHS *tRule=rhs->getFirst(); tRule!=NULL; tRule=rhs->getNext())
	{
		if (randVal<tRule->getWeight())
		{
			return tRule;
		}
	}

	errorMsg(EMT_WARNING, "I could not pick a RHSSet", "MTCrule::pickRHSSet()");

	return NULL;
}

@


1.7
log
@added punctuation processing to grammar definition language using {}
@
text
@d5 1
a5 1
 * $Id: rule.cc,v 1.6 1996/01/13 10:18:10 markc Exp markc $
d8 3
d32 1
a32 1
static char rcsid []  = "@@(#)$Id: rule.cc,v 1.6 1996/01/13 10:18:10 markc Exp markc $";
d431 3
a433 1
			if (maxSize==0)
@


1.6
log
@use new sentnode enabled sentence models
@
text
@d5 1
a5 1
 * $Id: rule.cc,v 1.5 1996/01/12 23:48:19 markc Exp markc $
d8 3
d29 1
a29 1
static char rcsid []  = "@@(#)$Id: rule.cc,v 1.5 1996/01/12 23:48:19 markc Exp markc $";
d45 1
a45 1
		rhs(NULL), allPunct(FALSE)
d55 2
a56 1
	: name(s), terminal(-1), totalWeight(0), rhs(NULL), allPunct(FALSE)
d105 1
d230 1
a230 5
	MTCstring delimeter="\t \t";

	s << r.name << ": " << endl;

	if (r.rhs==NULL)
d232 1
a232 1
		s << "* * * * * THIS RULE'S RHS IS A NULL MTClist <MTCruleRHS> * ";
d236 5
a240 1
		if (r.rhs->getCount()==0)
d242 1
a242 1
			s << "\t\tterminal(" << r.getTerminal() << ")" << endl; 
d246 5
a250 1
			for(MTCruleRHS *trhs=r.rhs->getFirst(); trhs!=NULL; trhs=r.rhs->getNext())
d252 6
a257 3
				s << delimeter;
				s << *trhs << endl;
				delimeter="\t|\t";
d260 2
a262 2
	
	s << "\t;" << endl << endl;
d405 1
a405 1
		if ((terminal==-1)||(allPunct==TRUE))
@


1.5
log
@dynamic grammars work system wide -- next step, constant expressions
@
text
@d5 1
a5 1
 * $Id: rule.cc,v 1.4 1996/01/10 22:15:49 markc Exp markc $
d8 3
d26 1
a26 1
static char rcsid []  = "@@(#)$Id: rule.cc,v 1.4 1996/01/10 22:15:49 markc Exp markc $";
d35 1
d41 2
a42 1
	: name("UNDEFINED_RULE"), terminal(0), totalWeight(0), rhs(NULL)
d52 1
a52 1
	: name(s), terminal(0), totalWeight(0), rhs(NULL)
d100 1
d122 1
a122 1
	terminal=0; 
d392 9
a400 2
	//	model.append(name);
		model.append(terminal);
@


1.4
log
@makeModel() works
@
text
@d5 1
a5 1
 * $Id: rule.cc,v 1.3 1996/01/10 20:41:59 markc Exp markc $
d8 3
d23 1
a23 1
static char rcsid []  = "@@(#)$Id: rule.cc,v 1.3 1996/01/10 20:41:59 markc Exp markc $";
d229 5
a233 1
		for(MTCruleRHS *trhs=r.rhs->getFirst(); trhs!=NULL; trhs=r.rhs->getNext())
d235 6
a240 3
			s << delimeter;
			s << *trhs << endl;
			delimeter="\t|\t";
d386 2
a387 1
		model.append(name);
@


1.3
log
@correctly parses and sets up grammar rules -- does not yet makeModel()
@
text
@d5 1
a5 1
 * $Id: rule.cc,v 1.2 1996/01/08 21:54:42 markc Exp markc $
d8 3
d20 1
a20 1
static char rcsid []  = "@@(#)$Id: rule.cc,v 1.2 1996/01/08 21:54:42 markc Exp markc $";
d24 1
d29 1
d357 68
@


1.2
log
@not quite ready
@
text
@d5 1
a5 1
 * $Id: rule.cc,v 1.1 1996/01/08 17:32:38 markc Exp markc $
d8 3
d17 1
a17 1
static char rcsid []  = "@@(#)$Id$";
d29 1
a29 1
	: name("UNDEFINED_RULE"), terminal(0), totalWeight(0)
d31 2
d39 1
a39 1
	: name(s), terminal(0), totalWeight(0)
d41 2
a48 2
	: 	name(r.name), rhs(r.rhs), 
		terminal(r.terminal), totalWeight(r.totalWeight)
d50 2
d55 34
d93 6
d102 34
d192 42
d238 83
a320 4
	name=aSrc.name;
	rhs=aSrc.rhs;
	terminal=aSrc.terminal;
	totalWeight=aSrc.totalWeight;
d324 30
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 * $Id$
d7 4
a10 1
 * $Log$
d14 1
a14 1
static char rcsid []  = "@@(#)$Id";
a24 1
/*
d26 1
d28 25
a53 1
*/
d113 1
a113 1
MTCrule & MTCrule::operator=(const MTCrule &aSrc)
d116 3
@
